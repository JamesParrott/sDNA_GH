#Option,Default,Description
from collections import OrderedDict
advanced_options = OrderedDict(
     startelev = dict(default = None, description = 'Name of field to read start elevation from')
    ,endelev = dict(default = None, description = 'Name of field to read end elevation from')
    ,metric = dict(default = 'angular', description = '"Metric – angular, euclidean, custom or one of the presets"')
    ,radius = dict(default = 'n', description = 'List of radii separated by commas')
    ,startelev = dict(default = None, description = 'Name of field to read start elevation from')
    ,endelev = dict(default = None, description = 'Name of field to read end elevation from')
    ,origweight = dict(default = None, description = 'Name of field to read origin weight from')
    ,destweight = dict(default = None, description = 'Name of field to read destination weight from')
    ,origweightformula = dict(default = None, description = 'Expression for origin weight (overrides origweight)')
    ,destweightformula = dict(default = None, description = 'Expression for destination weight (overrides destweight)')
    ,weight = dict(default = None, description = 'Name of field to read weight from. Applies weight field to both origins and destinations.')
    ,zonesums = dict(default = None, description = 'Expressions to sum over zones (see zone sums below)')
    ,lenwt = dict(default = None, description = 'Specifies that weight field is per unit length')
    ,custommetric = dict(default = None, description = 'Specified field name to read custom metric from')
    ,xytol = dict(default = None, description = 'Manual override xy tolerance for fixing endpoint connectivity.  ')
    ,ztol = dict(default = None, description = 'Manual override z tolerance for fixing endpoint connectivity.  ')
    ,outputgeodesics = dict(default = None, description = 'Output geometry of all pairwise geodesics in analysis (careful – this can create a lot of data)')
    ,outputdestinations = dict(default = None, description = 'Output geometry of all pairwise destinations in analysis (careful – this can create a lot of data).  Useful in combination with origins for creating a map of distance/metric from a given origin.')
    ,outputhulls = dict(default = None, description = 'Output geometry of all convex hulls in analysis ')
    ,outputnetradii = dict(default = None, description = 'Output geometry of all network radii in analysis')
    ,origins = dict(default = None, description = '"Only compute selected origins (provide feature IDs as comma separated list).  Useful in conjunction with outputgeodesicsm, outputdestinations, outputhulls, outputnetradii."')
    ,destinations = dict(default = None, description = 'Only compute selected destinations (ditto)')
    ,nonetdata = dict(default = None, description = 'Don’t output any network data (used in conjunction with geometry outputs)')
    ,pre = dict(default = None, description = 'Prefix text of your choice to output column names')
    ,post = dict(default = None, description = 'Postfix text of your choice to output column names')
    ,nobetweenness = dict(default = None, description = 'Don’t calculate betweenness (saves a lot of time)')
    ,nojunctions = dict(default = None, description = 'Don’t calculate junction measures (saves time)')
    ,nohull = dict(default = None, description = 'Don’t calculate convex hull measures (saves time)')
    ,linkonly = dict(default = None, description = 'Only calculate individual link measures.  ')
    ,outputsums = dict(default = None, description = '"Output sum measures SAD, SCF etc as well as means MAD, MCF etc."')
    ,probroutes = dict(default = None, description = 'Output measures of problem routes – routes which exceed the length of the radius')
    ,forcecontorigin = dict(default = None, description = '"Force origin link to be handled in continuous space, even in a discrete analysis.  Prevents odd results on very long links."')
    ,nqpdn = dict(default = 1, description = 'Custom numerator power for NQPD equation')
    ,nqpdd = dict(default = 1, description = 'Custom denominator power for NQPD equation')
    ,skipzeroweightorigins = dict(default = None, description = 'Skips calculation of any output measures for origins with zero weight.  Saves a lot of time if many such origins exist.')
    ,skipzeroweightdestinations = dict(default = 1, description = 'Zero weight destinations are skipped by default.  Note this will exclude them from geometry outputs; if this is not desired behaviour then set skipzeroweightdestinations=0')
    ,skiporiginifzero = dict(default = None, description = '"Specified field name.  If this field is zero, the origin will be skipped.  Allows full customization of skipping origins."')
    ,skipfraction = dict(default = 1, description = '"Set to value n, skips calculation for (n-1)/n origins.  Effectively the increment value when looping over origins."')
    ,skipmod = dict(default = 0, description = 'Chooses which origins are calculated if skipfraction?1.  Effectively the initial value when looping over origins: every skipfractionth origin is computed starting with the skipmodth one.')
    ,nostrictnetworkcut = dict(default = None, description = 'Don’t constrain geodesics to stay within radius.  This will create a lot more ‘problem routes’.  Only alters behaviour of betweenness measures (not closeness).')
    ,probrouteaction = dict(default = 'ignore', description = '"Take special action for problem routes that exceed the radius by a factor greater than probroutethreshold.  Can be set to ignore, discard or reroute.  Reroute changes geodesic to shortest Euclidean path.  Only alters betweenness output, not closeness."')
    ,probroutethreshold = dict(default = 1.2, description = '"Threshold over which probrouteaction is taken.  Note this does not affect computation of probroutes measures, which report on all routes which exceed the radius length regardless of this setting."')
    ,outputdecomposableonly = dict(default = None, description = 'output only measures which are decomposable i.e. can be summed over different origins (useful for parallelization)')
    ,linkcentretype = dict(default = None, description = '"Angular for angular analysis, Euclidean otherwise",Override link centre types – angular or Euclidean')
    ,lineformula = dict(default = None, description = 'Formula for line metric in hybrid analysis (see below)')
    ,juncformula = dict(default = 0, description = 'Formula for junction turn metric in hybrid analysis (see below)')
    ,bidir = dict(default = None, description = 'Output betweenness for each direction separately')
    ,oneway = dict(default = None, description = 'Specified field name to read one way data from (see note 1 below)')
    ,vertoneway = dict(default = None, description = 'Specified field name to read vertical one way data from (see note 1 below)')
    ,oversample = dict(default = 1, description = 'Number of times to run the analysis; results given are the mean of all runs.  Useful for sampling hybrid metrics with random components.')
    ,odmatrix = dict(default = None, description = 'Read OD matrix from input tables (a 2d table must be present)')
    ,zonedist = dict(default = 'euc', description = '"Set expression to determine how zone weights are distributed over links in each zone, or 0 to skip distribution (all lines receive entire zone weight)"')
    ,intermediates = dict(default = None, description = 'Set expression for intermediate link filter.  Geodesics are discarded unless they pass through link where expression is nonzero.')
    ,disable = dict(default = None, description = 'Set expression to switch off links (links switched off when expression evaluates nonzero)')
    ,outputskim = dict(default = None, description = 'Output skim matrix file')
    ,skimorigzone = dict(default = None, description = 'Origin zone field (must be text) for skim matrix')
    ,skimdestzone = dict(default = None, description = 'Destination zone field (must be text) for skim matrix')
    ,skimzone = dict(default = None, description = 'Skim matrix zone field for both origin and destination (sets both skimorigzone and skimdestzone)')
    ,bandedradii = dict(default = None, description = 'Divide radius into bands: for each radius only include links outside the previous radius')
    )